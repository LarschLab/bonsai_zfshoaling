<?xml version="1.0" encoding="utf-8"?>
<WorkflowBuilder Version="2.4.0"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xmlns:q1="clr-namespace:Bonsai.uEye;assembly=Bonsai.uEye"
                 xmlns:cv="clr-namespace:Bonsai.Vision;assembly=Bonsai.Vision"
                 xmlns:rx="clr-namespace:Bonsai.Reactive;assembly=Bonsai.Core"
                 xmlns:sys="clr-namespace:System;assembly=mscorlib"
                 xmlns:gl="clr-namespace:Bonsai.Shaders;assembly=Bonsai.Shaders"
                 xmlns:q2="clr-namespace:System.Windows.Forms;assembly=System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                 xmlns:scr="clr-namespace:Bonsai.Scripting;assembly=Bonsai.Scripting"
                 xmlns:io="clr-namespace:Bonsai.IO;assembly=Bonsai.System"
                 xmlns:wie="clr-namespace:Bonsai.Windows.Input;assembly=Bonsai.Windows.Input"
                 xmlns:dsp="clr-namespace:Bonsai.Dsp;assembly=Bonsai.Dsp"
                 xmlns="https://bonsai-rx.org/2018/workflow">
  <Workflow>
    <Nodes>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="q1:uEyeCapture">
          <q1:DeviceId xsi:nil="true" />
          <q1:ConfigFile>2048x1380_10fps_slowClock_4.92.ini</q1:ConfigFile>
        </Combinator>
      </Expression>
      <Expression xsi:type="MemberSelector">
        <Selector>Image</Selector>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="cv:BackgroundSubtraction">
          <cv:BackgroundFrames>10</cv:BackgroundFrames>
          <cv:AdaptationRate>0.01</cv:AdaptationRate>
          <cv:ThresholdValue>27</cv:ThresholdValue>
          <cv:ThresholdType>Binary</cv:ThresholdType>
          <cv:SubtractionMethod>Dark</cv:SubtractionMethod>
        </Combinator>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="cv:Threshold">
          <cv:ThresholdValue>35</cv:ThresholdValue>
          <cv:MaxValue>255</cv:MaxValue>
          <cv:ThresholdType>Binary</cv:ThresholdType>
        </Combinator>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="dsp:RunningAverage">
          <dsp:Alpha>1</dsp:Alpha>
        </Combinator>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="cv:FindContours">
          <cv:Mode>External</cv:Mode>
          <cv:Method>ChainApproxNone</cv:Method>
          <cv:Offset>
            <cv:X>0</cv:X>
            <cv:Y>0</cv:Y>
          </cv:Offset>
          <cv:MinArea>200</cv:MinArea>
          <cv:MaxArea xsi:nil="true" />
        </Combinator>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="cv:BinaryRegionAnalysis" />
      </Expression>
      <Expression xsi:type="scr:PythonTransform">
        <scr:Name>SortContours</scr:Name>
        <scr:Script>import clr
clr.AddReference("Bonsai.Vision")
from Bonsai.Vision import ConnectedComponent
from System.Collections.Generic import IList
from System import Tuple

@returns(IList[ConnectedComponent])

def process(value):

  tupRoundAll=[]
  for c in value:

    y=c.Centroid.Y
    yr=(int(y/400)*400)
    x=c.Centroid.X
    xr=(int(x/400)*400)
    
    tupRoundAll.append((yr,xr))
  
  so=[i[0] for i in sorted(enumerate(tupRoundAll), key=lambda x:x[1])]

  s=[value[i] for i in so]

  return s</scr:Script>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="FloatProperty">
          <Value>0</Value>
        </Combinator>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:Timer">
          <rx:DueTime>PT0S</rx:DueTime>
          <rx:Period>PT2S</rx:Period>
        </Combinator>
      </Expression>
      <Expression xsi:type="Mod">
        <Operand xsi:type="WorkflowProperty" TypeArguments="sys:Int64">
          <Value>2</Value>
        </Operand>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:CombineLatest" />
      </Expression>
      <Expression xsi:type="Equal" />
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="gl:UpdateFrame" />
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="wie:KeyDown">
          <wie:Filter>A</wie:Filter>
          <wie:SuppressRepetitions>false</wie:SuppressRepetitions>
        </Combinator>
      </Expression>
      <Expression xsi:type="Equal">
        <Operand xsi:type="WorkflowProperty" TypeArguments="q2:Keys">
          <Value>A</Value>
        </Operand>
      </Expression>
      <Expression xsi:type="PropertyMapping">
        <PropertyMappings>
          <Property Name="Value" />
        </PropertyMappings>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="BooleanProperty">
          <Value>false</Value>
        </Combinator>
      </Expression>
      <Expression xsi:type="NestedWorkflow">
        <Name>ROI File</Name>
        <Workflow>
          <Nodes>
            <Expression xsi:type="ExternalizedMapping">
              <Property Name="FileName" />
            </Expression>
            <Expression xsi:type="io:CsvReader">
              <io:FileName>E:\00_bonsai_ffmpeg_out\ROIdef2019-02-04T11_58_58.csv</io:FileName>
              <io:ScanPattern>%i %i %i %i %i %i</io:ScanPattern>
              <io:SkipRows>0</io:SkipRows>
            </Expression>
            <Expression xsi:type="WorkflowOutput" />
          </Nodes>
          <Edges>
            <Edge From="0" To="1" Label="Source1" />
            <Edge From="1" To="2" Label="Source1" />
          </Edges>
        </Workflow>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:ToList" />
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:CombineLatest" />
      </Expression>
      <Expression xsi:type="scr:PythonTransform">
        <scr:Script>import clr
clr.AddReference("OpenTK")
clr.AddReference("OpenCV.Net")
from System.Collections.Generic import IList
from OpenCV.Net import CV, Point2f, Mat,Depth

from OpenTK import Vector2, Vector3
from System import Array, Single, Random,Tuple


dlOld=[]
dl=[]

@returns(Tuple[str,str])
def process(value):
  global dlOld,dl
  allwells=[]
  detected=value.Item1
  projected=value.Item2

  ppl=[8,12,22,26]#[0,4,10,14]

  pl=[]
  boxWidth=(projected[0].Item3/2)

  for p in ppl:
    x=projected[p].Item1+boxWidth
    y=projected[p].Item2+boxWidth

    pl.append([x,y])

  try:

    dpl=[0,1,2,3]
    
    dlOld=dl
    dl=[]
    for d in dpl:
      x=detected[d].Centroid.X
      y=detected[d].Centroid.Y
      dl.append([int(x),int(y)])

  except:
    dl=dlOld
    #print 'hello'
      

  try:
    for i in dpl:
      welldata = (pl[i][0],pl[i][1],dl[i][0],dl[i][1])
      wellstr = "%i %i %i %i" % welldata
      allwells.append(wellstr)
    
  except:
    allwells=""

  v=" ".join(allwells)
  sAll=[]
  try:
    a=[int(x) for x in v.split()]
    b=Array[Point2f]([Point2f(a[0],a[1]),Point2f(a[4],a[5]),Point2f(a[8],a[9]),Point2f(a[12],a[13])])
    c=Array[Point2f]([Point2f(a[2],a[3]),Point2f(a[6],a[7]),Point2f(a[10],a[11]),Point2f(a[14],a[15])])
    values = Array[float]([1,1,1,1,1,1,1,1,1])

    h = Mat.FromArray(values, 3, 3, Depth.F64, 1)

    CV.GetPerspectiveTransform(c,b,h)

    
    for i in range(3):
      for j in range(3):
        va=float(h.Item[i*3+j].Val0)
        da=(va)
        s = "%0.8f" % da
        sAll.append(s) 
  except:
    pass
  return Tuple.Create(" ".join(sAll),v)
  #except:
   # return ""

def unload():
  global dlOld,dl
  dlOld=None
  dl=None</scr:Script>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:CombineLatest" />
      </Expression>
      <Expression xsi:type="Condition">
        <Workflow>
          <Nodes>
            <Expression xsi:type="WorkflowInput">
              <Name>Source1</Name>
            </Expression>
            <Expression xsi:type="MemberSelector">
              <Selector>Item2</Selector>
            </Expression>
            <Expression xsi:type="WorkflowOutput" />
          </Nodes>
          <Edges>
            <Edge From="0" To="1" Label="Source1" />
            <Edge From="1" To="2" Label="Source1" />
          </Edges>
        </Workflow>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:Take">
          <rx:Count>1</rx:Count>
        </Combinator>
      </Expression>
      <Expression xsi:type="MemberSelector">
        <Selector>Item1.Item1</Selector>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="io:TextWriter">
          <io:FileName>E:\00_bonsai_ffmpeg_out\calibrationOut.csv</io:FileName>
          <io:Suffix>Timestamp</io:Suffix>
          <io:Buffered>true</io:Buffered>
          <io:Overwrite>false</io:Overwrite>
          <io:Append>false</io:Append>
        </Combinator>
      </Expression>
      <Expression xsi:type="MemberSelector">
        <Selector>Item1</Selector>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="rx:CombineLatest" />
      </Expression>
      <Expression xsi:type="Condition">
        <Workflow>
          <Nodes>
            <Expression xsi:type="WorkflowInput">
              <Name>Source1</Name>
            </Expression>
            <Expression xsi:type="MemberSelector">
              <Selector>Item3</Selector>
            </Expression>
            <Expression xsi:type="WorkflowOutput" />
          </Nodes>
          <Edges>
            <Edge From="0" To="1" Label="Source1" />
            <Edge From="1" To="2" Label="Source1" />
          </Edges>
        </Workflow>
      </Expression>
      <Expression xsi:type="scr:PythonTransform">
        <scr:Script>import clr
clr.AddReference("OpenTK")
from OpenTK import Vector2, Vector3
from System import Array, Tuple
clr.AddReference("OpenCV.Net")
from OpenCV.Net import *

def transf(x,y,s):
  values = Array[float]([float(el) for el in s.split()])

  h = Mat.FromArray(values, 3, 3, Depth.F64, 1)

  values1 = Array[float]([x,y])
  values2 = Array[float]([1,1])

  point = Mat.FromArray(values1, 1, 1, Depth.F64,2)
  out = Mat.FromArray(values2, 1, 1, Depth.F64,2)

  CV.PerspectiveTransform(point,out,h)

  x=out.Item[0].Val0
  y=out.Item[0].Val1

  return x,y


@returns(Array[Vector3])
def process(value):

  allwells=[]

  wellList=[8,12,22,26]#[0,4,10,14]
  posList=[]

  for w in wellList:
    well=value.Item1[w]


    x = (well.Item1+well.Item3/2.)
    y = (well.Item2+well.Item3/2.)

    allwells.append(Vector3(2*(x-1024)/2048.0,-2*(y-690)/1380.0,25))

    s=value.Item4
    if len(s)&gt;1:
      xt,yt=transf(x,y,s)
      allwells.append(Vector3(2*(xt-1024)/2048.0,-2*(yt-690)/1380.0,5))

    

  ar=Array[Vector3](allwells)
  return ar</scr:Script>
      </Expression>
      <Expression xsi:type="Combinator">
        <Combinator xsi:type="gl:DrawArrays">
          <gl:ShaderName>Particles</gl:ShaderName>
          <gl:DrawMode>Points</gl:DrawMode>
          <gl:Usage>DynamicDraw</gl:Usage>
          <gl:VertexAttributes>
            <gl:VertexAttributeMapping>
              <gl:Size>3</gl:Size>
              <gl:Normalized>false</gl:Normalized>
              <gl:Type>Float</gl:Type>
            </gl:VertexAttributeMapping>
          </gl:VertexAttributes>
        </Combinator>
      </Expression>
    </Nodes>
    <Edges>
      <Edge From="0" To="1" Label="Source1" />
      <Edge From="1" To="2" Label="Source1" />
      <Edge From="2" To="3" Label="Source1" />
      <Edge From="3" To="4" Label="Source1" />
      <Edge From="4" To="5" Label="Source1" />
      <Edge From="5" To="6" Label="Source1" />
      <Edge From="6" To="7" Label="Source1" />
      <Edge From="7" To="20" Label="Source1" />
      <Edge From="8" To="11" Label="Source2" />
      <Edge From="9" To="10" Label="Source1" />
      <Edge From="10" To="11" Label="Source1" />
      <Edge From="11" To="12" Label="Source1" />
      <Edge From="12" To="28" Label="Source3" />
      <Edge From="13" To="28" Label="Source2" />
      <Edge From="14" To="15" Label="Source1" />
      <Edge From="15" To="16" Label="Source1" />
      <Edge From="16" To="17" Label="Source1" />
      <Edge From="17" To="22" Label="Source2" />
      <Edge From="18" To="19" Label="Source1" />
      <Edge From="19" To="28" Label="Source1" />
      <Edge From="19" To="20" Label="Source2" />
      <Edge From="20" To="21" Label="Source1" />
      <Edge From="21" To="22" Label="Source1" />
      <Edge From="21" To="27" Label="Source1" />
      <Edge From="22" To="23" Label="Source1" />
      <Edge From="23" To="24" Label="Source1" />
      <Edge From="24" To="25" Label="Source1" />
      <Edge From="25" To="26" Label="Source1" />
      <Edge From="27" To="28" Label="Source4" />
      <Edge From="28" To="29" Label="Source1" />
      <Edge From="29" To="30" Label="Source1" />
      <Edge From="30" To="31" Label="Source1" />
    </Edges>
  </Workflow>
</WorkflowBuilder>
